vunit axi_fifo_wide_inst(axi_fifo_wide(synthesis))
{
-- set all declarations to run on clk_i
   default clock is rising_edge(clk_i);

   signal f_old_m_bytes : natural range 0 to G_M_DATA_BYTES;
   signal f_m_data      : std_logic_vector(G_M_DATA_BYTES * 8 - 1 downto 0);
   signal f_old_m_data  : std_logic_vector(G_M_DATA_BYTES * 8 - 1 downto 0);

   signal f_s_bytes      : natural range 0 to 1000;
   signal f_m_bytes      : natural range 0 to 1000;
   signal f_s_length     : natural range 0 to 1000;
   signal f_m_length     : natural range 0 to 1000;
   signal f_s_length_cnt : natural range 0 to 9;
   signal f_m_length_cnt : natural range 0 to 9;

   signal f_data : std_logic_vector(7 downto 0);
   attribute anyconst : boolean;
   attribute anyconst of f_data : signal is true;

   signal f_data_in  : boolean;
   signal f_data_out : boolean;

   f_old_m_bytes_proc : process (clk_i)
   begin
     if rising_edge(clk_i) then
       f_old_m_bytes <= m_bytes_o;
       if rst_i = '1' then
         f_old_m_bytes <= 0;
       end if;
     end if;
   end process f_old_m_bytes_proc;

   f_m_data_proc : process (all)
   begin
     f_m_data <= m_data_o;
     -- Clear out unused bits
     for b in G_M_DATA_BYTES - 1 downto 0 loop
       if b >= f_old_m_bytes then
         f_m_data(b * 8 + 7 downto b * 8) <= X"00";
       end if;
     end loop;
   end process f_m_data_proc;

   f_old_m_data_proc : process (clk_i)
   begin
     if rising_edge(clk_i) then
       f_old_m_data <= m_data_o;
       -- Clear out unused bits
       for b in G_M_DATA_BYTES - 1 downto 0 loop
         if b >= m_bytes_o then
           f_old_m_data(b * 8 + 7 downto b * 8) <= X"00";
         end if;
       end loop;
     end if;
   end process f_old_m_data_proc;

   f_data_proc : process (clk_i)
   begin
     if rising_edge(clk_i) then
       if s_valid_i = '1' and s_ready_o = '1' then
         for i in 0 to G_S_DATA_BYTES - 1 loop
           if i < s_bytes_i then
             if s_data_i(8 * i + 7 downto 8 * i) = f_data then
               f_data_in <= true;
             end if;
           end if;
         end loop;
       end if;

       if m_valid_o = '1' and m_ready_i = '1' then
         for i in 0 to G_M_DATA_BYTES - 1 loop
           if i < m_bytes_o then
             if m_data_o(8 * i + 7 downto 8 * i) = f_data then
               f_data_out <= true;
             end if;
           end if;
         end loop;
       end if;

       if rst_i = '1' then
         f_data_in  <= false;
         f_data_out <= false;
       end if;
     end if;
   end process f_data_proc;

   f_bytes_proc : process (clk_i)
   begin
     if rising_edge(clk_i) then
       if s_valid_i = '1' and s_ready_o = '1' then
         if s_last_i = '1' then
           f_s_length <= f_s_bytes + s_bytes_i;
           f_s_length_cnt <= f_s_length_cnt + 1;
           f_s_bytes <= 0;
         else
           f_s_bytes <= f_s_bytes + s_bytes_i;
         end if;
       end if;

       if m_valid_o = '1' and m_ready_i = '1' then
         if m_last_o = '1' then
           f_m_length <= f_m_bytes + minimum(m_bytes_o, m_bytes_i);
           f_m_length_cnt <= f_m_length_cnt + 1;
           f_m_bytes <= 0;
         else
           f_m_bytes <= f_m_bytes + minimum(m_bytes_o, m_bytes_i);
         end if;
       end if;

       if rst_i = '1' then
         f_s_bytes <= 0;
         f_m_bytes <= 0;
         f_s_length <= 0;
         f_m_length <= 0;
         f_s_length_cnt <= 0;
         f_m_length_cnt <= 0;
       end if;

     end if;
   end process f_bytes_proc;


-----------------------------
-- ASSERTIONS ABOUT OUTPUTS
-----------------------------

-- Master must be empty after reset
   f_master_after_reset_empty : assert always {rst_i} |=> {not m_valid_o};

-- Master valid and data must be stable until accepted
   f_master_stable : assert always {m_valid_o and not m_ready_i and not rst_i} |=>
      {stable(m_valid_o) and f_m_data = f_old_m_data};

-- Master bytes must be non-decreasing until accepted
   f_master_bytes : assert always {m_valid_o and not m_ready_i and not rst_i} |=>
      {m_bytes_o >= f_old_m_bytes};

-- Slave must be ready after reset
   f_slave_after_reset_ready : assert always {rst_i} |=> {s_ready_o};

-- Data on master must have been from slave
   f_master_data_seen : assert always {f_data_out and rst_i = '0'} |-> {f_data_in};

-- Packet length must match
   f_master_length : assert always {f_s_length_cnt = f_m_length_cnt and rst_i = '0'} |->
     {f_s_length = f_m_length};

-----------------------------
-- ASSUMPTIONS ABOUT INPUTS
-----------------------------

-- Require reset at startup.
   f_reset : assume {rst_i};

-- Input bytes must be a valid number.
   f_s_bytes_valid : assume always {s_bytes_i <= G_S_DATA_BYTES};
   f_m_bytes_valid : assume always {m_bytes_i <= G_M_DATA_BYTES};


--------------------------------------------
-- COVER STATEMENTS TO VERIFY REACHABILITY
--------------------------------------------

   f_master_full : cover {not s_ready_o and not rst_i};

} -- vunit axi_fifo_wide_inst(axi_fifo_wide(synthesis))

